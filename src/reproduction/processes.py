"""Time-series simulators used in the reproduction pipeline."""

from __future__ import annotations

import math
from dataclasses import dataclass
from typing import Optional

import numpy as np
from scipy.ndimage import gaussian_filter1d


@dataclass
class RNGConfig:
    """Helper dataclass storing the state of a numpy random generator."""

    seed: Optional[int] = None

    def generator(self) -> np.random.Generator:
        return np.random.default_rng(self.seed)


def simulate_brownian_motion(n: int, dt: float = 1.0, sigma: float = 1.0, seed: Optional[int] = None) -> np.ndarray:
    """Simulate a standard Brownian motion with Gaussian increments."""

    rng = RNGConfig(seed).generator()
    increments = rng.normal(scale=math.sqrt(dt) * sigma, size=n)
    return np.cumsum(increments)


def simulate_poisson_process(n: int, rate: float = 10.0, dt: float = 1.0, seed: Optional[int] = None) -> np.ndarray:
    """Simulate a Poisson counting process with intensity ``rate``."""

    rng = RNGConfig(seed).generator()
    counts = rng.poisson(lam=rate * dt, size=n)
    return np.cumsum(counts - np.mean(counts))


def simulate_mrw(
    n: int,
    hurst: float = 0.7,
    log_vol_scale: float = 0.25,
    smoothing: float = 32.0,
    seed: Optional[int] = None,
) -> np.ndarray:
    """Simulate a simple multifractal random walk.

    The implementation follows Bacry et al. (2001). A log-normal volatility
    field is generated by smoothing white Gaussian noise. The resulting series is
    multiplied with fractional Brownian increments approximated with fractional
    Gaussian noise obtained via spectral synthesis.
    """

    rng = RNGConfig(seed).generator()

    # Spectral synthesis of fractional Gaussian noise.
    freqs = np.fft.rfftfreq(n)
    freqs[0] = freqs[1]
    spectrum = np.power(freqs, -(hurst + 0.5))
    phases = rng.normal(size=spectrum.shape) + 1j * rng.normal(size=spectrum.shape)
    fg_noise = np.fft.irfft(phases * spectrum, n=n)

    log_vol = gaussian_filter1d(rng.normal(size=n), smoothing / 6.0)
    log_vol = log_vol - log_vol.mean()
    vol = np.exp(log_vol_scale * log_vol)
    increments = vol * fg_noise
    return np.cumsum(increments)


def simulate_hawkes_process(
    n: int,
    baseline: float = 0.5,
    alpha: float = 0.8,
    beta: float = 0.3,
    seed: Optional[int] = None,
) -> np.ndarray:
    """Simulate a discrete-time Hawkes process with an exponential kernel."""

    rng = RNGConfig(seed).generator()
    counts = np.zeros(n)
    intensity = baseline
    for t in range(n):
        lam = min(max(intensity, 1e-6), 100.0)
        counts[t] = rng.poisson(lam)
        intensity = baseline + (intensity - baseline) * math.exp(-beta) + alpha * counts[t]
    return np.cumsum(counts - counts.mean())


def simulate_turbulence_surrogate(
    n: int,
    seed: Optional[int] = None,
    cascade_steps: int = 6,
) -> np.ndarray:
    """Generate a log-normal multiplicative cascade as a turbulence surrogate."""

    rng = RNGConfig(seed).generator()
    signal = np.ones(n)
    block = n
    for _ in range(cascade_steps):
        block //= 2
        if block <= 1:
            break
        weights = rng.lognormal(mean=0.0, sigma=0.5, size=n // block)
        weights /= weights.mean()
        signal = np.repeat(weights, block) * signal
    noise = rng.normal(scale=0.1, size=n)
    return np.cumsum(signal + noise - (signal + noise).mean())


def simulate_sp500_surrogate(
    n: int,
    seed: Optional[int] = None,
    omega: float = 0.0001,
    alpha: float = 0.05,
    beta: float = 0.9,
) -> np.ndarray:
    """Simulate a simple GARCH(1,1) process as a financial surrogate."""

    rng = RNGConfig(seed).generator()
    returns = np.zeros(n)
    variance = np.full(n, omega / (1 - alpha - beta))
    for t in range(1, n):
        variance[t] = omega + alpha * returns[t - 1] ** 2 + beta * variance[t - 1]
        returns[t] = rng.normal(scale=math.sqrt(max(variance[t], 1e-8)))
    return np.cumsum(returns)


__all__ = [
    "simulate_brownian_motion",
    "simulate_poisson_process",
    "simulate_mrw",
    "simulate_hawkes_process",
    "simulate_turbulence_surrogate",
    "simulate_sp500_surrogate",
]
